cpp

참조자, 오버로딩(함수 중복), 인라인 함수, new delete

캡슐화와 벙보 은닉으로 프로그램의 안전성을 향상

상속, 다형성

템플릿

캡슐활 : 데이터와 알고리즘을 하나의 단위(클래스)로 묶는 것 
상속 : 비슷한 클래스가 이미 존재하고 있다면 그 클래스를 가져다 사용하는것(코드의 재사용을 극대화)
다형성 : 같은 이름의 함수나 연산자가 컴파일 과정 또는 실행 시간에 상황에 따라서 여러가지로 해석 가능(오리 너구리)

절차적 언어 --> 절차를 중시 하는것 goto나 jump로 코드를 제어 할 수 있는데 프로그램 규모가 커지면 복잡해진다.

객체지향 : 캡슐화를 이용해 데이터와 알고리즘을 묶는다.
독립된 객체들의 모임으로 인식
이 객체들간 메시지를 주고받는 방법으로 데이터를 처리


변수,상수

상수 -> 원주율과 같이 이미 정해져 변경할 수 없는 값
변수 -> 변경이 가능
식별자 --> 변수 or 상수등 객체의 이름

상수(const)
ex

리터럴 이라고도 부름
const int a =1;
or
#define PI 3.14
void main()
{
~~
}

c에서 0을 거짓 0이 아닌것을 참

헷갈리기 떄문에 cpp에선 bool 자료형이 생겼다(true, false)

자료형의 범위를 기억하자

비트 연산자.

//////////////////////
소수 구하기
void main()
{
	int k;
	for (int i = 2; i < 101; ++i)
	{
		for (k = 2; k < i; ++k)
			if (i%k== 0) break;
		if (k == i)
		{
			cout << i << "\t";
		}
	}
}

sqrt() ()안의 숫자의 제곱근을 구하는 라이브러리 함수.


함수는 서브루틴, 프로시저라고 불리기도 하며
객체지향 언어에서 메소드라고 불리기도 한다.

함수의 중복 모호성 때문에 문제가 되지만
자료형의 선언에 따라 모호성이 근거가 되어 모호성이 없어진다.

인라인 함수
c언어의 매크로 함수와 동작은 같으나 매개변수 자료형을 철저히 검사하기 떄문에
잘못 사용할 수 있는 위험ㅇ르 크게 줄인다.
함수 앞에 inline을 붙여서 사용

지역변수와 전역변수

지역변수 {}로 정의되는 블록안에 선언되는 변수
{}안에서만 의미가 있고 외부에서는 이미가 없다.
해당 블록이 끝나면 소멸

함수 외부에 선언되고 팔일 범위를 갖는다.
어떤 함수나 블록에서도 접근이 가능 프로그램이 시작할 때 만들어지고 프로그램이 끝나야 없어진다
자료 공유한다는 점은 편리하나 각각의 함수가 서로 영향을 줄 수 있게 되어 프로그램이 불안정하게 된다.

extern 외부(다른 소스파일)에 선언한 변수를 사용하기 위해 반드시 extern 선언

static 

1. 지역변수를 static으로 처리하는 경우
2. 전역변수나 함수를 static으로 처리하는 경우
3. 클래스의 멤버 변수나 멤버 함수를 static으로 처리하는 경우


static으로 선언한 직연변수를 정적 지역변수라고한다.
-> 전역변수와 동일한 생존기간을 갖는다. 함수 안에서만 사용 가능하지만 프로그램이 실행되는동안 생존
p129참고 

a배열의 첫번째 인자는 배열a의 주소다

함수로 배열을 전달할 경우
배열의 시작주소[배열이름],배열의 길이
문자열 경우 길이 전달 필요x 문자열 끝은 널값 널값이 나오면 문자열이 끝난것으로 생각해버려서

구조체
클래스와 같다.

함슈의 호출은 기본적으로 값에 의한 호출 = 콜바이 벨류 이다.
173참고

파일 입출력

포인터

모든 메모리는 주소를 갖는다, 포인터 변수는 이러한 메모리 주소를 저장하기 위해 사용되는 변수를 말한다. 포인터 변수를 간단히 포인터
라 부른다.

자료형 *포인터변수명;
(어떤 변수의 주소값을 알아내려면 를 사용한다)

값의 의한 호출 은 주소값에 의한 호출로 해결 가능 p216

참조형.
레퍼런스라고도 부르며 기존의 메모리 공간에 별명을 붙이는 방법
자료형 & 참조변수명 = 앞에서 선언되 변수명;'
&참조 연산자.
참조자 
기존 변수들을 보다 간편하게 사용하기 위해
함수의 매개변수로 사용하기 위해
함수의 반환형을 사용하기 위해

참조에 의한 호출->값의 복사가 일어나지 않는다.
참조자 반환

객체지향
추상화
캡슐화 - 정보은닉
상속 - 코드 재활용 극대화, 코드길이 줄어든다, 고드 유지보수 용이
다형성 - 함수 중복, 동적 바인딩(실행시간에 객체의 타입에 따라 적절한 함수가 실행되도록 연결)

생성자와 소멸자
생성자 -> 모든변수나 객체는 사용되기 전에 초기화 되어야 한다.
소멸자 -> 동적 생성 메모리 해제를 해주는 처리과정 (메모리 누수가 생길 수 있음) --> 소멸자가 이를 해결
생성자는 선언 순서대로 생성되고
소멸자는 가장 최근에 생성된 객체부터 소멸된다.

객체의 복사와 복사 생성자.

변수들 처럼 객체도 =를 사용하여 복사 할 수 있다
-> 복사 생성자
함수에서 객체를 반환하는 경우에도 복사가 일어난다
함수로  매개변수를 보낼 때 복사가 일어난다

복사 생성자 
-> 클래스명(const 클래스명 & 참조객체명){}
복사 생성자 
-> 다른 객체로 부터 새로운 객체를 생성 할 때
-> 함수의 맥개변수로 객체가 전달될 때
-> 함수가 객체를 반활 할 때

class는 defalute로 private를 잡는다.

얕은복사 -> 메모리 영역을 그대로 다른 객체의 메모리로 복사

동적 메모리 할당
new
--> ex) int* pi =new int
Complex* pi = new Complex
char* pf =new char[10]

delete
->동적으로 할당되어ㅏㅆ던 메모리는 반납해야한다.
delete pi
delete[] pf

상속시 생성자 -> 부모->자식순으로 생성

멤버의 재정의(사용 자제하자)
멤버 함수의 재정의

중복정의(오버로딩)
재정의(오버라이딩)
오버로딩은 같은 이림의 매개변수가다른 함수를 여러개만드는것.
오버라이딩은 부모 클래스의 멤버 함수에서 몸체만 교체하는 것이다.
즉 부모 클래스의 멤버 함수와 이름, 매개변수, 반환형이 모두 같아야한다.

오버라이딩 -> 다형성의 핵심

가상함수->동적 바인딩
*C++에서는 가상함수가 아닌 모든 함수들에게 정적바인딩을 적용하였다.
가상 함수를 하나라도 사용한다면 소멸자도 가상 함수로 만들어 주느것이 좋다 -> 메모리 누구 방지.
